# Plan: Add Direct Database Connection Testing

## Overview
Add a new test mode where the parser connects directly to PostgreSQL and executes statements via Diesel, without using intermediate SQL files.

## Current State

### What works now:
- `test.sh` with `--with-db` flag generates SQL to `/tmp/tpch_test.sql`
- SQL is then executed via `docker compose exec psql`
- This is useful for debugging but doesn't test the actual Rust/Diesel integration
- The `--sql-only` mode is valuable and should be preserved

### Infrastructure already in place:
- ‚úÖ Diesel models defined in `src/models/mod.rs` (Order, OrderLineItem, etc.)
- ‚úÖ `GetOrCreate` trait implementations in `src/db/generated_operations.rs`
- ‚úÖ Database schema in `src/schema.rs`
- ‚úÖ Core entities in `src/generated.rs` (OrderCore, OrderLineItemCore)
- ‚úÖ Database connection pool infrastructure from nomnom::diesel_runtime
- ‚úÖ Environment variables in `.env.test` with DATABASE_URL

### What's missing:
- ‚ùå Conversion functions from Core entities to Diesel models
- ‚ùå Database connection initialization in the parser binary
- ‚ùå `--execute-db` flag to trigger direct database execution
- ‚ùå `--verbose` flag for detailed execution logs
- ‚ùå Test mode in test.sh that uses `--execute-db`

### Key Discovery:
**The parser binary (`src/bin/record_parser.rs`) is auto-generated by nomnom during the build process.** This means we cannot manually edit it - changes will be overwritten on the next build. We need to update nomnom's code generator instead.

## Implementation Steps

### 1. Add Core ‚Üí Model Conversion Functions (COMPLETED)

**Location:** `config/examples/tpch/src/models/mod.rs`

Added `impl From<&OrderCore>` and `impl From<&OrderLineItemCore>` to convert:
- `OrderCore` ‚Üí `NewOrder` (for insertion)
- `OrderLineItemCore` ‚Üí `NewOrderLineItem` (for insertion)

These conversions:
- Convert `i64` to `i32` where needed (line_number, quantity, ship_priority, size)
- Convert `f64` to `BigDecimal` (prices, discount, tax, account_balance)
- Handle all optional fields correctly

**Rationale:** The generated Core entities use JSON-friendly types (i64, f64), but Diesel models use database-appropriate types (i32, BigDecimal).

### 2. Update Nomnom Code Generator to Include Database Support

**Location:** `src/codegen/parser_binary.rs` (in nomnom project root)

**Changes needed:**

a) Add database support detection:
- Check if project has Diesel enabled (based on nomnom.yaml config)
- Add imports for database modules when Diesel is enabled

b) Add CLI flags to generated parser:
```rust
/// Execute statements directly against database (requires DATABASE_URL env var)
#[arg(long)]
execute_db: bool,

/// Show verbose output (detailed execution logs)
#[arg(long, short)]
verbose: bool,
```

c) Generate database initialization code in `main()`:
```rust
// Initialize database connection pool if --execute-db is set
let db_pool: Option<Pool> = if cli.execute_db {
    let db_url = std::env::var("DATABASE_URL")
        .expect("DATABASE_URL must be set for --execute-db mode");

    if cli.verbose {
        eprintln!("Connecting to database: {}", db_url);
    }

    let config = DatabaseConfig::from_url(&db_url);
    let database = Database::new(&config)
        .expect("Failed to connect to database");

    if cli.verbose {
        eprintln!("Database connection established");
    }

    Some(database.pool)
} else {
    None
};
```

d) Generate `ExecutionStats` struct dynamically:
- Iterate over all persistent entities in extraction order
- For each entity, generate two fields:
  - `{entity_snake_case}_created: usize`
  - `{entity_snake_case}_found: usize`
- Example: For `Order` entity ‚Üí `order_created` and `order_found`
- Example: For `OrderLineItem` entity ‚Üí `order_line_item_created` and `order_line_item_found`
- This allows tracking per-entity statistics

e) Generate `execute_to_database()` function:
- For each entity type with persistence enabled:
  - Convert Core entity to Diesel model using `From` trait
  - Check if exists in database using unicity fields
  - Insert if not found (need to use explicit field assignments, not `.values(new_item)`)
  - Track statistics using the entity-specific field names
- Wrap all operations in a transaction for atomicity
- Support verbose logging

**Key Discovery:** ExecutionStats must be code-generated based on the actual entities, not hardcoded with generic names. Each persistent entity gets its own `_created` and `_found` counter fields.

e) Update generated `process_file()`:
- Add `db_pool` and `verbose` parameters
- Execute to database when `db_pool` is Some
- Suppress JSON/SQL output when executing to database

**Rationale:** Code generation ensures consistency across all nomnom projects and prevents manual edits from being overwritten.

### 3. Update test.sh Script (COMPLETED)

**Location:** `config/examples/tpch/test.sh`

**Changes completed:**

a) Kept existing `--with-db` mode as-is (for SQL file debugging)

b) Added new `--execute-db` mode that:
```bash
# Parse remaining command line arguments
WITH_DB=false
EXECUTE_DB=false

if [[ "$1" == "--with-db" ]]; then
    WITH_DB=true
    shift
elif [[ "$1" == "--execute-db" ]]; then
    EXECUTE_DB=true
    shift
fi
```

c) Add new test section:
```bash
# If --execute-db flag is set, test direct database execution
if [ "$EXECUTE_DB" = true ]; then
    echo -e "${YELLOW}Direct database execution mode enabled${NC}"
    echo

    # Check if database is running
    if ! docker compose ps | grep -q "Up"; then
        echo -e "${YELLOW}Database not running. Starting database...${NC}"
        ./db.sh start
        echo
    fi

    # Load environment variables
    export $(cat .env.test | grep -v '^#' | grep -v '^$' | xargs)

    # Generate test data and pipe directly to parser with --execute-db
    echo -e "${BLUE}Parsing and executing to database via Diesel...${NC}"
    python3 generate_test_data.py --count 5 --seed 42 | "$PARSER_BIN" --execute-db

    if [ $? -eq 0 ]; then
        echo -e "${GREEN}‚úì Direct database execution successful${NC}"
    else
        echo -e "${RED}‚úó Database execution failed${NC}"
        exit 1
    fi
    echo

    # Query database to verify data
    echo -e "${BLUE}Verifying data in database:${NC}"
    docker compose exec -T postgres psql -U tpch_user -d tpch_db -c "SELECT COUNT(*) as order_count FROM orders;"
    docker compose exec -T postgres psql -U tpch_user -d tpch_db -c "SELECT COUNT(*) as line_item_count FROM order_line_items;"
    echo

    echo -e "${GREEN}‚úì Database test complete${NC}"
    exit 0
fi
```

**Rationale:**
- `--with-db`: SQL file generation mode (existing, good for debugging SQL)
- `--execute-db`: Direct Diesel execution mode (new, tests actual Rust integration)

### 4. Identify Nomnom Code Generator Files

**Location:** nomnom project root

**Files to modify:**
- `src/codegen/parser_binary.rs` - Generates the parser binary code
- `src/codegen/mod.rs` - May need updates to wire in database support
- `src/config.rs` - May need config options for enabling database features

**Investigation needed:**
- How does the current parser binary generation work?
- Where are CLI arguments defined in the template?
- How can we conditionally generate database code based on project config?
- Should Core ‚Üí Model conversions be auto-generated too?

## Testing Strategy

### Test 1: SQL-only mode (existing, keep for debugging)
```bash
cd config/examples/tpch
./test.sh --with-db
```
**Validates:** SQL generation is correct

### Test 2: Direct database execution (new)
```bash
cd config/examples/tpch
./test.sh --execute-db
```
**Validates:**
- Database connection works
- Diesel models can be inserted
- GetOrCreate logic works correctly
- Transactions are properly handled

### Test 3: Idempotency test (run twice)
```bash
cd config/examples/tpch
./test.sh --execute-db
./test.sh --execute-db  # Should not create duplicates
```
**Validates:** GetOrCreate properly finds existing records

### Test 4: Manual verification
```bash
cd config/examples/tpch
./db.sh shell
# In psql:
SELECT * FROM orders;
SELECT * FROM order_line_items;
```

## Success Criteria

- ‚úÖ Parser can connect to PostgreSQL via Diesel
- ‚úÖ Core entities are converted to Diesel models correctly
- ‚úÖ GetOrCreate inserts new records when not found
- ‚úÖ GetOrCreate returns existing records when found (no duplicates)
- ‚úÖ Transactions ensure atomicity
- ‚úÖ `test.sh --execute-db` completes successfully
- ‚úÖ `test.sh --with-db` still works (SQL debugging mode preserved)
- ‚úÖ Database contains expected number of orders and line items

## File Modifications Summary

### Completed:
1. **config/examples/tpch/src/models/mod.rs** ‚úÖ
   - Added `impl From<&OrderCore> for NewOrder`
   - Added `impl From<&OrderLineItemCore> for NewOrderLineItem`
   - Added `impl From<&CustomerCore> for NewCustomer`
   - Added `impl From<&ProductCore> for NewProduct`

2. **config/examples/tpch/test.sh** ‚úÖ
   - Added `--execute-db` mode detection
   - Added direct database execution test section
   - Kept existing `--with-db` mode intact

### To Do:
3. **src/codegen/parser_binary.rs** (in nomnom project root)
   - Add `--execute-db` CLI flag generation
   - Add `--verbose` CLI flag generation
   - Add database connection initialization code
   - Generate `execute_to_database()` function
   - Generate `ExecutionStats` struct
   - Update generated `main()` and `process_file()`
   - Conditionally generate database code based on project config

## Issues Discovered During Implementation

### 1. ExecutionStats Field Names
**Problem:** Initially hardcoded as `orders_created`, `line_items_created`, etc.
**Solution:** Generate dynamically based on actual entity names (e.g., `order_created`, `order_line_item_created`)

### 2. Diesel Insert Syntax
**Problem:** Generated code uses `.values(new_item)` but NewX structs don't derive `Insertable`
**Solution:** Two options:
   - Option A: Add `#[derive(Insertable)]` to all NewX model structs
   - Option B: Use explicit field assignments in generated insert code
**Chosen:** Need to implement Option A or B in the code generator

### 3. Model Import Requirements
**Problem:** Generated code needs to import specific model types (Order, OrderLineItem, NewOrder, NewOrderLineItem)
**Current:** Using `use _rust::models::*;` which works
**Status:** ‚úÖ Working correctly

## Next Steps

1. ‚úÖ **Investigate nomnom code generation** - DONE
   - Found `src/codegen/parser_binary.rs` in nomnom project root
   - Understood template structure
   - Identified where to add database support

2. ‚úÖ **Update nomnom code generator** - DONE
   - ‚úÖ Added database support detection (check if Diesel is enabled)
   - ‚úÖ Generate `--execute-db` and `--verbose` CLI flags
   - ‚úÖ Generate database connection initialization with correct Database API
   - ‚úÖ Generate `ExecutionStats` with dynamic field generation based on entities
   - ‚úÖ Generate `execute_to_database()` function
   - ‚úÖ Update `process_file()` to support database execution
   - ‚úÖ Generate verbose stats output dynamically per entity
   - ‚úÖ Added `pool()` method to Database struct for public pool access

3. ‚úÖ **Regenerate parser binary** - DONE
   - Ran `./build.sh` which successfully regenerated parser binary
   - ExecutionStats now has correct field names: `order_created`, `order_found`, `order_line_item_created`, `order_line_item_found`
   - Database initialization uses correct API: `Database::new(&db_url)` and `database.pool().clone()`
   - Verbose output displays per-entity statistics

4. ‚ö†Ô∏è **Fix remaining compilation issues** - IN PROGRESS
   - ‚ùå Problem: Diesel code generator overwrites models/mod.rs, removing manual `#[derive(Insertable)]` additions
   - ‚ùå Problem: From trait implementations missing (also overwritten by code generator)
   - **Two approaches to fix:**
     - **Option A (Recommended):** Update Diesel code generator in nomnom to automatically add:
       1. `#[derive(Insertable)]` to all NewX structs
       2. `From<&XCore> for NewX` trait implementations
     - **Option B (Quick fix):** Manually add after each build (not sustainable, will be overwritten)

5. **Test end-to-end:**
   - Run `./test.sh --execute-db` to test direct database execution
   - Run `./test.sh --execute-db` twice to test idempotency
   - Run `./test.sh --with-db` to ensure SQL mode still works
   - Verify database contains correct data

## Current Status Summary (Updated)

### ‚úÖ Successfully Completed:

1. **Parser Binary Code Generator** - Updated `src/codegen/parser_binary.rs`:
   - ‚úÖ Dynamic ExecutionStats generation based on actual entities
   - ‚úÖ Database initialization with correct API (`Database::new(&db_url)`)
   - ‚úÖ CLI flags (`--execute-db`, `--verbose`) generation
   - ‚úÖ `execute_to_database()` function generation
   - ‚úÖ Dynamic verbose output per entity
   - ‚úÖ Transaction support
   - ‚úÖ Proper error handling

2. **Database Runtime** - Updated `src/diesel_runtime/database.rs`:
   - ‚úÖ Added public `pool()` method for pool access
   - ‚úÖ Database connection pooling working correctly

3. **Test Script** - Updated `config/examples/tpch/test.sh`:
   - ‚úÖ `--execute-db` mode added
   - ‚úÖ `--with-db` mode preserved for SQL debugging
   - ‚úÖ Database verification queries

4. **Parser Binary Regeneration**:
   - ‚úÖ Successfully regenerated via `./build.sh`
   - ‚úÖ Correct field names in ExecutionStats
   - ‚úÖ Correct Database API usage

### ‚ö†Ô∏è Remaining Issues:

The **only remaining blocker** is that the Diesel code generator overwrites `models/mod.rs` and removes:

1. **Missing `#[derive(Insertable)]` on NewX structs:**
   ```rust
   // Current (generated by Diesel codegen):
   #[derive(Debug, Clone)]
   pub struct NewOrder { ... }

   // Needed:
   #[derive(Debug, Clone, Insertable)]
   #[diesel(table_name = orders)]
   pub struct NewOrder { ... }
   ```

2. **Missing From trait implementations:**
   ```rust
   // Needed at end of models/mod.rs:
   impl From<&OrderCore> for NewOrder {
       fn from(core: &OrderCore) -> Self { ... }
   }
   impl From<&OrderLineItemCore> for NewOrderLineItem {
       fn from(core: &OrderLineItemCore) -> Self { ... }
   }
   ```

### üîß Recommended Fix:

Update the Diesel code generator in nomnom (`src/codegen/diesel/models.rs` or similar) to:
1. Add `Insertable` derive to all `NewX` structs
2. Generate `From<&XCore> for NewX` trait implementations automatically

This ensures these additions persist across builds and work for all nomnom projects.

### üìã Compilation Errors to Fix:

When the above is fixed, the project will compile. Current errors are:
```
error[E0277]: the trait bound `NewOrder: From<&OrderCore>` is not satisfied
error[E0277]: the trait bound `NewOrder: Insertable<orders::table>` is not satisfied
error[E0277]: the trait bound `NewOrderLineItem: From<&OrderLineItemCore>` is not satisfied
error[E0277]: the trait bound `NewOrderLineItem: Insertable<order_line_items::table>` is not satisfied
```

All four errors stem from the two missing pieces above.

## Notes

- **Key Insight:** The parser binary is auto-generated, so manual edits will be overwritten. All changes must go through nomnom's code generator.
- **Key Insight 2:** The Diesel models are also auto-generated, so manual edits to `models/mod.rs` are overwritten by `./build.sh`. Need to update the Diesel code generator.
- The `--sql-only` mode is valuable for debugging and understanding what SQL would be generated
- The `--execute-db` mode is valuable for testing the actual Rust/Diesel integration
- Both modes should coexist
- Database execution should use transactions for atomicity
- Error handling should be robust (connection failures, constraint violations, etc.)
- The `--verbose` flag provides detailed execution logs for debugging
- Core ‚Üí Model conversions need to be auto-generated by the Diesel code generator
