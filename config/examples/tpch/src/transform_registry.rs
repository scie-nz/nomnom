//! Transform registry for entity field extraction.
//!
//! This file is auto-generated by nomnom.
//! DO NOT EDIT MANUALLY - changes will be overwritten.
//!
//! This module provides a TransformRegistry that implements the interface expected
//! by nomnom-generated code, wrapping PyTransformRegistry for Python transform calls.

use pyo3::prelude::*;
use std::collections::HashMap;
use serde_json::Value;

/// Transform Registry
///
/// Provides transform function calls that automatically acquire Python GIL.
/// This implements the interface expected by nomnom's generated code.
pub struct TransformRegistry;

impl TransformRegistry {
    /// Create a new transform registry
    pub fn new() -> Self {
        Self
    }

    /// Call a transform function
    ///
    /// This method automatically acquires the Python GIL and delegates to PyTransformRegistry.
    ///
    /// # Arguments
    ///
    /// * `name` - Transform function name
    /// * `args` - Arguments as JSON Value HashMap
    ///
    /// # Returns
    ///
    /// * `Ok(Value)` - Transform succeeded, returns JSON Value (String, Array, Null, etc.)
    /// * `Err(String)` - Transform failed (error message)
    ///
    /// # Note
    ///
    /// This implements the transform registry interface expected by nomnom-generated code.
    /// It delegates to nomnom::PyTransformRegistry with the configured Python module.
    pub fn call_transform(
        &self,
        name: &str,
        args: &HashMap<String, Value>,
    ) -> Result<Value, String> {
        Python::with_gil(|py| {
            // Use nomnom's PyTransformRegistry with configured Python transforms module
            let py_registry = nomnom::PyTransformRegistry::new("tpch_example._rust");

            // Convert JSON Value args to Option<String> kwargs for Python
            let mut kwargs = HashMap::new();

            for (key, value) in args {
                let opt_string = match value {
                    Value::String(s) => Some(s.clone()),
                    Value::Null => None,
                    Value::Number(n) => Some(n.to_string()),
                    Value::Bool(b) => Some(b.to_string()),
                    _ => Some(value.to_string()),
                };
                kwargs.insert(key.clone(), opt_string);
            }

            // Try calling as a list-valued transform first (for transforms like extract_segments)
            match py_registry.call_transform_list(py, name, kwargs.clone()) {
                Ok(list_result) => {
                    // Transform succeeded and returned a list (empty or not)
                    let values: Vec<Value> = list_result.into_iter()
                        .map(Value::String)
                        .collect();
                    Ok(Value::Array(values))
                }
                Err(_list_err) => {
                    // List extraction failed - try as string-valued transform
                    let result = py_registry.call_transform(py, name, kwargs)
                        .map_err(|e| format!("Python transform '{}' failed: {}", name, e))?;

                    // Convert Option<String> to JSON Value
                    match result {
                        Some(s) => Ok(Value::String(s)),
                        None => Ok(Value::Null),
                    }
                }
            }
        })
    }
}

impl Default for TransformRegistry {
    fn default() -> Self {
        Self::new()
    }
}

// Implement the nomnom trait for the PyO3 TransformRegistry
impl nomnom::runtime::transform_registry::TransformRegistry for TransformRegistry {
    fn call_transform(
        &self,
        name: &str,
        args: &HashMap<String, Value>,
    ) -> Result<Value, String> {
        // Delegate to the struct's method
        self.call_transform(name, args)
    }
}
