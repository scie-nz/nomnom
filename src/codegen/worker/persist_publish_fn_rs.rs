/// Generate persist() and publish() functions for entities
///
/// - persist() for persistent entities: inserts to database
/// - publish() for transient entities: publishes to NATS

use crate::codegen::EntityDef;
use crate::codegen::worker::DatabaseType;
use std::error::Error;
use std::io::Write;
use std::path::Path;

/// Generate persist and publish functions module
pub fn generate_persist_publish_file(
    entities: &[EntityDef],
    output_dir: &Path,
    db_type: DatabaseType,
) -> Result<(), Box<dyn Error>> {
    let file_path = output_dir.join("src/persist_publish.rs");
    let mut output = std::fs::File::create(&file_path)?;

    writeln!(output, "// Auto-generated persist and publish functions")?;
    writeln!(output, "// Persistent entities: persist() to database")?;
    writeln!(output, "// Transient entities: publish() to NATS\n")?;

    writeln!(output, "use crate::entities::*;")?;
    writeln!(output, "use crate::database::DbConnection;")?;
    writeln!(output, "use crate::error::AppError;")?;
    writeln!(output, "use async_nats::jetstream;")?;
    writeln!(output, "use diesel::prelude::*;")?;
    writeln!(output, "use diesel::sql_types::{{Text, Integer, BigInt, Double, Bool, Date, Numeric, Nullable}};\n")?;

    // Generate functions for each entity
    for entity in entities {
        if entity.is_root() || entity.is_abstract {
            continue;
        }

        if entity.is_persistent(entities) {
            generate_persist_function(&mut output, entity, entities, db_type)?;
        } else {
            generate_publish_function(&mut output, entity)?;
        }
        writeln!(output)?;
    }

    Ok(())
}

/// Generate persist() function for a persistent entity
fn generate_persist_function(
    output: &mut std::fs::File,
    entity: &EntityDef,
    all_entities: &[EntityDef],
    db_type: DatabaseType,
) -> Result<(), Box<dyn Error>> {
    let db_config = entity.get_database_config(all_entities)
        .ok_or(format!("Entity {} is persistent but has no database config", entity.name))?;

    let table_name = &db_config.conformant_table;
    let unicity_fields = &db_config.unicity_fields;

    // Get persistence config (checking parent if this entity extends another)
    let persistence_config = if entity.persistence.is_some() {
        entity.persistence.as_ref()
    } else if let Some(ref parent_name) = entity.extends {
        all_entities.iter()
            .find(|e| &e.name == parent_name)
            .and_then(|parent| parent.persistence.as_ref())
    } else {
        None
    };

    // Get primary key name if it's autogenerated
    let autogenerated_pk_name = if db_config.autogenerate_conformant_id {
        Some(db_config.conformant_id_column.clone())
    } else {
        None
    };

    // Generate doc comment
    writeln!(output, "/// Persist {} to database", entity.name)?;
    writeln!(output, "pub async fn persist_{}(", to_snake_case(&entity.name))?;
    writeln!(output, "    entity: &{},", entity.name)?;
    writeln!(output, "    conn: &mut DbConnection,")?;
    writeln!(output, ") -> Result<(), AppError> {{")?;

    // Generate unicity check if there are unicity fields
    // Only require non-nullable, non-computed unicity fields to be non-empty
    // Skip constant/derived fields (those with computed_from) from the check
    let non_nullable_unicity_checks: Vec<String> = unicity_fields.iter()
        .filter_map(|field_name| {
            // Find the field definition
            entity.fields.iter()
                .find(|f| &f.name == field_name)
                .filter(|f| {
                    // Only include non-nullable fields
                    if f.nullable {
                        return false;
                    }
                    // Skip computed/constant fields (from other entities)
                    if f.computed_from.is_some() {
                        return false;
                    }
                    true
                })
                .map(|_| format!("(entity.{}.is_some() && entity.{}.as_ref().map(|s| !s.is_empty()).unwrap_or(false))", field_name, field_name))
        })
        .collect();

    if !non_nullable_unicity_checks.is_empty() {
        writeln!(output, "    // Check non-nullable, non-computed unicity fields are non-empty")?;
        writeln!(output, "    if {} {{", non_nullable_unicity_checks.join(" && "))?;
    } else {
        writeln!(output, "    {{")?;
    }

    // Generate SQL query based on database type
    // If field_overrides are specified in persistence config, only insert those fields
    // Otherwise, insert all fields from the entity
    // Exclude autogenerated primary keys from the INSERT statement
    // IMPORTANT: When using field_overrides (especially from parent), only include fields that exist in current entity

    let mut field_names: Vec<String> = if let Some(persistence) = persistence_config {
        if !persistence.field_overrides.is_empty() {
            // Get set of field names that actually exist in this entity
            let entity_field_names: std::collections::HashSet<String> = entity.fields.iter()
                .map(|f| f.name.clone())
                .collect();

            // Only include field_overrides that exist in the entity
            persistence.field_overrides.iter()
                .map(|f| f.name.clone())
                .filter(|name| entity_field_names.contains(name))
                .collect()
        } else {
            entity.fields.iter()
                .map(|f| f.name.clone())
                .collect()
        }
    } else {
        entity.fields.iter()
            .map(|f| f.name.clone())
            .collect()
    };

    // Remove autogenerated primary key from field list
    if let Some(ref pk_name) = autogenerated_pk_name {
        field_names.retain(|f| f != pk_name);
    }

    let placeholders = if db_type == DatabaseType::PostgreSQL {
        (1..=field_names.len())
            .map(|i| format!("${}", i))
            .collect::<Vec<_>>()
            .join(", ")
    } else {
        vec!["?"; field_names.len()].join(", ")
    };

    writeln!(output, "        #[cfg(feature = \"postgres\")]")?;
    writeln!(output, "        {{")?;
    if !unicity_fields.is_empty() {
        let conflict_fields = unicity_fields.join(", ");
        writeln!(output, "            diesel::sql_query(")?;
        writeln!(output, "                r#\"INSERT INTO {} ({}) VALUES ({}) ON CONFLICT ({}) DO NOTHING\"#",
            table_name,
            field_names.join(", "),
            placeholders,
            conflict_fields
        )?;
        writeln!(output, "            )")?;
    } else {
        writeln!(output, "            diesel::sql_query(")?;
        writeln!(output, "                r#\"INSERT INTO {} ({}) VALUES ({})\"#",
            table_name,
            field_names.join(", "),
            placeholders
        )?;
        writeln!(output, "            )")?;
    }
    writeln!(output, "        }}")?;

    writeln!(output, "        #[cfg(feature = \"mysql\")]")?;
    writeln!(output, "        {{")?;
    if !unicity_fields.is_empty() {
        writeln!(output, "            diesel::sql_query(")?;
        writeln!(output, "                r#\"INSERT IGNORE INTO {} ({}) VALUES ({})\"#",
            table_name,
            field_names.join(", "),
            placeholders
        )?;
        writeln!(output, "            )")?;
    } else {
        writeln!(output, "            diesel::sql_query(")?;
        writeln!(output, "                r#\"INSERT INTO {} ({}) VALUES ({})\"#",
            table_name,
            field_names.join(", "),
            placeholders
        )?;
        writeln!(output, "            )")?;
    }
    writeln!(output, "        }}")?;

    // Bind field values (only those in field_names)
    for field_name in &field_names {
        // Find the field definition to get its type
        if let Some(field) = entity.fields.iter().find(|f| &f.name == field_name) {
            let sql_type = map_field_to_sql_type(&field.field_type);
            // List types are never wrapped in Option, so never use Nullable binding
            let is_list = field.field_type.starts_with("List[") || field.field_type.starts_with("Vec<");
            if field.nullable && !is_list {
                writeln!(output, "        .bind::<Nullable<{}>, _>(&entity.{})", sql_type, field.name)?;
            } else {
                writeln!(output, "        .bind::<{}, _>(&entity.{})", sql_type, field.name)?;
            }
        }
    }

    writeln!(output, "        .execute(conn)")?;
    writeln!(output, "        .map_err(|e| AppError::ValidationError(format!(\"Failed to insert {}: {{}}\", e)))?;", entity.name)?;

    writeln!(output, "    }}")?;
    writeln!(output, "    Ok(())")?;
    writeln!(output, "}}")?;

    Ok(())
}

/// Generate publish() function for a transient entity
fn generate_publish_function(
    output: &mut std::fs::File,
    entity: &EntityDef,
) -> Result<(), Box<dyn Error>> {
    // Generate doc comment
    writeln!(output, "/// Publish {} to NATS", entity.name)?;
    writeln!(output, "pub async fn publish_{}(", to_snake_case(&entity.name))?;
    writeln!(output, "    entity: &{},", entity.name)?;
    writeln!(output, "    jetstream: &jetstream::Context,")?;
    writeln!(output, ") -> Result<(), AppError> {{")?;

    writeln!(output, "    let mut entity_json = serde_json::Map::new();")?;

    // Add all fields to JSON
    for field in &entity.fields {
        // List types are never wrapped in Option, non-nullable types are also not wrapped
        let is_list = field.field_type.starts_with("List[") || field.field_type.starts_with("Vec<");
        let is_optional = field.nullable && !is_list;

        if is_optional {
            writeln!(output, "    if let Some(ref val) = entity.{} {{", field.name)?;
            writeln!(output, "        entity_json.insert(\"{}\".to_string(), serde_json::json!(val));", field.name)?;
            writeln!(output, "    }}")?;
        } else {
            // Non-optional field - always include
            writeln!(output, "    entity_json.insert(\"{}\".to_string(), serde_json::json!(&entity.{}));", field.name, field.name)?;
        }
    }

    writeln!(output)?;
    writeln!(output, "    // Only publish if entity has actual data")?;
    writeln!(output, "    if !entity_json.is_empty() {{")?;
    writeln!(output, "        let entity_json_str = serde_json::to_string(&entity_json)")?;
    writeln!(output, "            .map_err(|e| AppError::ValidationError(format!(\"Failed to serialize {}: {{}}\", e)))?;", entity.name)?;
    writeln!(output, "        let stream_subject = format!(\"entities.{}\");", entity.name)?;
    writeln!(output, "        jetstream.publish(stream_subject.clone(), entity_json_str.into()).await")?;
    writeln!(output, "            .map_err(|e| {{")?;
    writeln!(output, "                eprintln!(\"[WORKER] Failed to publish {} to {{}}: {{:?}}\", stream_subject, e);", entity.name)?;
    writeln!(output, "                AppError::ValidationError(format!(\"NATS publish failed: {{}}\", e))")?;
    writeln!(output, "            }})?;")?;
    writeln!(output, "        eprintln!(\"[WORKER] âœ“ Published {} to {{}}\", stream_subject);", entity.name)?;
    writeln!(output, "    }} else {{")?;
    writeln!(output, "        eprintln!(\"[WORKER] Skipped {} (no data extracted from segments)\");", entity.name)?;
    writeln!(output, "    }}")?;

    writeln!(output, "    Ok(())")?;
    writeln!(output, "}}")?;

    Ok(())
}

/// Map entity field type to Diesel SQL type
fn map_field_to_sql_type(field_type: &str) -> &str {
    match field_type.to_lowercase().as_str() {
        "string" => "Text",
        "integer" | "int" => "Integer",
        "bigint" | "long" => "BigInt",
        "double" | "float" => "Double",
        "boolean" | "bool" => "Bool",
        "date" => "Date",
        "decimal" | "numeric" => "Numeric",
        "vec<string>" | "list[string]" => "Text", // Serialized as JSON
        _ => "Text", // Default to Text
    }
}

/// Convert CamelCase to snake_case
fn to_snake_case(s: &str) -> String {
    let mut result = String::new();
    let mut prev_is_upper = false;

    for (i, ch) in s.chars().enumerate() {
        if ch.is_uppercase() {
            if i > 0 && !prev_is_upper {
                result.push('_');
            }
            result.push(ch.to_lowercase().next().unwrap());
            prev_is_upper = true;
        } else {
            result.push(ch);
            prev_is_upper = false;
        }
    }

    result
}
