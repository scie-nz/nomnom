/// Generate MySQL schema SQL for entities

use crate::codegen::EntityDef;
use super::{BenthosConfig, to_snake_case};
use std::error::Error;

/// Generate CREATE TABLE statement for an entity
pub fn generate_mysql_schema(
    entity: &EntityDef,
    _config: &BenthosConfig,
) -> Result<String, Box<dyn Error>> {
    let table_name = to_snake_case(&entity.name);

    let mut columns = vec![
        "  id BIGINT AUTO_INCREMENT PRIMARY KEY".to_string(),
    ];

    // Generate columns from entity fields
    for field in &entity.fields {
        let column_name = &field.name;
        let column_type = map_field_type_to_mysql(&field.field_type, field.nullable);
        columns.push(format!("  {} {}", column_name, column_type));
    }

    // Add metadata columns
    columns.push("  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP".to_string());

    // Add indexes
    columns.push("  INDEX idx_created_at (created_at)".to_string());

    // TODO: Add unique constraints based on entity configuration
    // For now, we'll assume message_id + set_id for idempotency if those fields exist
    let has_message_id = entity.fields.iter().any(|f| f.name == "message_id");
    let has_set_id = entity.fields.iter().any(|f| f.name == "set_id");

    if has_message_id && has_set_id {
        columns.push("  UNIQUE KEY idx_unique (message_id, set_id)".to_string());
    } else if has_message_id {
        columns.push("  INDEX idx_message_id (message_id)".to_string());
    }

    Ok(format!(r#"-- Auto-generated MySQL schema for {}
-- Generated by nomnom from entity definition
--
-- Source type: {}
-- Fields: {}

CREATE TABLE IF NOT EXISTS {} (
{}
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
"#,
        entity.name,
        entity.source_type,
        entity.fields.len(),
        table_name,
        columns.join(",\n")
    ))
}

/// Map entity field type to MySQL column type
fn map_field_type_to_mysql(field_type: &str, nullable: bool) -> String {
    let base_type = match field_type {
        "String" => "VARCHAR(1024)",
        "Integer" | "i32" | "i64" => "BIGINT",
        "Boolean" | "bool" => "BOOLEAN",
        "DateTime" => "TIMESTAMP",
        "Float" | "f32" | "f64" => "DOUBLE",
        _ => "TEXT", // Fallback for unknown types
    };

    if nullable {
        format!("{} NULL", base_type)
    } else {
        format!("{} NOT NULL", base_type)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_map_field_type_to_mysql() {
        assert_eq!(map_field_type_to_mysql("String", true), "VARCHAR(1024) NULL");
        assert_eq!(map_field_type_to_mysql("String", false), "VARCHAR(1024) NOT NULL");
        assert_eq!(map_field_type_to_mysql("Integer", true), "BIGINT NULL");
        assert_eq!(map_field_type_to_mysql("Boolean", false), "BOOLEAN NOT NULL");
        assert_eq!(map_field_type_to_mysql("DateTime", true), "TIMESTAMP NULL");
    }
}
