use crate::codegen::EntityDef;
use crate::codegen::utils::to_snake_case;
use std::error::Error;

use super::HelmChartConfig;

/// Generate values.yaml with smart defaults derived from entities
pub fn generate_values_yaml(
    entities: &[EntityDef],
    config: &HelmChartConfig,
) -> Result<String, Box<dyn Error>> {
    let permanent_entities: Vec<_> = entities
        .iter()
        .filter(|e| e.source_type.to_lowercase() == "permanent" && !e.is_abstract)
        .collect();

    let transient_entities: Vec<_> = entities
        .iter()
        .filter(|e| e.source_type.to_lowercase() == "derived" && !e.is_abstract)
        .collect();

    // Smart defaults
    let worker_replicas = calculate_worker_replicas(permanent_entities.len());
    let worker_memory = calculate_worker_memory(&permanent_entities);
    let nats_storage = calculate_nats_storage(transient_entities.len());

    let mut values = String::new();

    values.push_str(&format!(r#"# values.yaml - AUTO-GENERATED by nomnom
# Chart version: {}
# Entities: {} total ({} permanent, {} transient)
#
# DO NOT EDIT MANUALLY - Regenerate with:
#   nomnom generate-helm-chart --entities config/entities --output helm-chart

global:
  databaseBackend: {}  # mysql or postgresql

# =============================================================================
# Ingestion Server
# =============================================================================
ingestionServer:
  enabled: true
  replicaCount: 2

  image:
    repository: hl7-ingestion-server
    tag: latest
    pullPolicy: IfNotPresent

  service:
    type: ClusterIP
    port: 8080

  resources:
    requests:
      memory: "256Mi"
      cpu: "100m"
    limits:
      memory: "512Mi"
      cpu: "500m"

  env: {{}}

# =============================================================================
# Worker
# =============================================================================
worker:
  enabled: true
  # Smart default based on {} permanent entities
  replicaCount: {}

  image:
    repository: hl7-worker
    tag: latest
    pullPolicy: IfNotPresent

  # Smart default based on entity field complexity
  resources:
    requests:
      memory: "{}"
      cpu: "200m"
    limits:
      memory: "{}"
      cpu: "1000m"

  env: {{}}

"#,
        config.chart_version,
        entities.len(),
        permanent_entities.len(),
        transient_entities.len(),
        config.database_backend,
        permanent_entities.len(),
        worker_replicas,
        worker_memory.requests,
        worker_memory.limits,
    ));

    // Benthos section
    if !transient_entities.is_empty() {
        values.push_str(&generate_benthos_values(&transient_entities)?);
    }

    // MySQL section
    if config.database_backend == "mysql" {
        values.push_str(&format!(r#"
# =============================================================================
# MySQL Database
# =============================================================================
mysql:
  enabled: true

  auth:
    database: hl7_ingestion
    username: root
    password: root_test  # CHANGE IN PRODUCTION
    rootPassword: root_test  # CHANGE IN PRODUCTION

  primary:
    persistence:
      enabled: true
      size: 20Gi

    resources:
      requests:
        memory: "512Mi"
        cpu: "250m"
      limits:
        memory: "2Gi"
        cpu: "1000m"

"#));
    }

    // Calculate stream sizes (split total storage between streams)
    let stream_storage = calculate_stream_storage(&nats_storage);
    // Convert to NATS config format (19G instead of 19Gi)
    let nats_storage_config = convert_to_nats_format(&nats_storage);

    // NATS section
    values.push_str(&format!(r#"
# =============================================================================
# NATS JetStream
# =============================================================================
nats:
  enabled: true

  natsBox:
    enabled: true

  config:
    jetstream:
      enabled: true
    # Smart default: {} based on {} transient entities
    merge:
      jetstream:
        max_file_store: {}
        max_memory_store: 0
        store_dir: /data

  jetstream:
    fileStore:
      enabled: true
      pvc:
        enabled: true
        size: {}

  # Stream size configuration for nats-stream-init-job
  streams:
    messages:
      maxBytes: {}
    entities:
      maxBytes: {}

  container:
    merge:
      resources:
        requests:
          memory: "256Mi"
          cpu: "100m"
        limits:
          memory: "512Mi"
          cpu: "500m"

"#,
        nats_storage,
        transient_entities.len(),
        nats_storage_config,
        nats_storage,
        stream_storage,
        stream_storage,
    ));

    Ok(values)
}

/// Generate Benthos values section
fn generate_benthos_values(transient_entities: &[&EntityDef]) -> Result<String, Box<dyn Error>> {
    let mut benthos_values = String::new();

    benthos_values.push_str(&format!(r#"
# =============================================================================
# Benthos Pipelines ({} transient entities)
# =============================================================================
benthos:
  enabled: true
  replicaCount: 1  # Default for non-repeated entities

  image:
    repository: jeffail/benthos
    tag: latest
    pullPolicy: IfNotPresent

  resources:
    requests:
      memory: "256Mi"
      cpu: "100m"
    limits:
      memory: "512Mi"
      cpu: "500m"

  warehouse:
    # Host should match your MySQL/MariaDB service name
    # Common values:
    #   - Bundled MySQL subchart: "{{ .Release.Name }}-mysql"
    #   - Bundled MariaDB subchart: "{{ .Release.Name }}-mariadb"
    #   - External database: "mysql.example.com"
    host: "mysql"
    port: 3306
    # Database name where Benthos will write transient entities
    database: "nomnom"
    # MySQL user with write access to the database
    username: "root"
    # Reference to Kubernetes secret containing MySQL password
    # The secret must have a 'password' key
    # Common values:
    #   - Bundled MySQL: "{{ .Release.Name }}-mysql"
    #   - Custom secret: "my-mysql-credentials"
    # Create secret: kubectl create secret generic mysql-credentials --from-literal=password=root_test
    existingSecret: "mysql-credentials"

  nats:
    url: "nats://{{{{ .Release.Name }}}}-nats:4222"

  schemaInit:
    enabled: true  # Run schema initialization job before deploying Benthos pipelines
    image:
      repository: mysql
      tag: "8.0"
      pullPolicy: IfNotPresent

  # Per-pipeline overrides
  pipelines:
"#,
        transient_entities.len(),
    ));

    // Generate per-entity settings
    for entity in transient_entities {
        let entity_snake = to_snake_case(&entity.name);

        // Determine replica count based on entity characteristics
        let replica_count = match &entity.repetition {
            Some(rep) if rep.to_lowercase() == "repeated" => 1,
            _ => 1,
        };

        benthos_values.push_str(&format!(
            r#"    {}:
      replicaCount: {}  # {}
"#,
            entity_snake,
            replica_count,
            if entity.repetition.as_ref().map(|r| r.to_lowercase() == "repeated").unwrap_or(false) {
                "repeated entity (high volume)"
            } else {
                "standard entity"
            }
        ));
    }

    Ok(benthos_values)
}

/// Calculate worker replicas based on permanent entity count
/// Formula: ceil(entity_count / 10), min 2, max 10
fn calculate_worker_replicas(permanent_count: usize) -> usize {
    let calculated = (permanent_count as f64 / 10.0).ceil() as usize;
    calculated.max(2).min(10)
}

/// Memory allocation for worker based on entity complexity
struct MemoryAllocation {
    requests: String,
    limits: String,
}

fn calculate_worker_memory(permanent_entities: &[&EntityDef]) -> MemoryAllocation {
    // Count total fields across all permanent entities
    let total_fields: usize = permanent_entities
        .iter()
        .map(|e| e.fields.len())
        .sum();

    // Simple heuristic: 10MB per field
    let base_mb = 256;
    let per_field_mb = 10;
    let requests_mb = base_mb + (total_fields * per_field_mb);
    let limits_mb = requests_mb * 2;

    MemoryAllocation {
        requests: format!("{}Mi", requests_mb),
        limits: format!("{}Mi", limits_mb),
    }
}

/// Calculate NATS storage based on transient entity count
fn calculate_nats_storage(transient_count: usize) -> String {
    // Formula: 1GB base + 500MB per transient entity
    let base_gb = 1;
    let per_entity_mb = 500;
    let total_mb = (base_gb * 1024) + (transient_count * per_entity_mb);

    if total_mb >= 1024 {
        format!("{}Gi", total_mb / 1024)
    } else {
        format!("{}Mi", total_mb)
    }
}

/// Calculate per-stream storage (40% of total for each stream, leaving headroom)
fn calculate_stream_storage(total_storage: &str) -> String {
    // Parse storage string (e.g., "10Gi" or "512Mi")
    let total_mb = if total_storage.ends_with("Gi") {
        let gb: usize = total_storage.trim_end_matches("Gi").parse().unwrap_or(1);
        gb * 1024
    } else if total_storage.ends_with("Mi") {
        total_storage.trim_end_matches("Mi").parse().unwrap_or(512)
    } else {
        512 // default
    };

    // Allocate 40% to each stream (80% total, 20% headroom)
    let stream_mb = (total_mb * 40) / 100;

    if stream_mb >= 1024 {
        format!("{}Gi", stream_mb / 1024)
    } else {
        format!("{}Mi", stream_mb)
    }
}

/// Convert Kubernetes storage format (19Gi) to NATS config format (19G)
fn convert_to_nats_format(k8s_storage: &str) -> String {
    // NATS expects "19G" or "512M", not "19Gi" or "512Mi"
    k8s_storage.replace("Gi", "G").replace("Mi", "M")
}

