//! Build configuration generation (Cargo.toml, pyproject.toml, lib.rs)
//!
//! **DEPRECATED**: This module is deprecated in favor of the unified BuildConfig
//! in project_config.rs. Use `project_config::BuildConfig` instead.
//!
//! The functions in this module now delegate to project_config::BuildConfig methods.

use std::path::Path;
use crate::codegen::fs_utils;

/// Configuration for build file generation
#[derive(Debug, Clone)]
pub struct BuildConfig {
    /// Package name (e.g., "data_processor")
    pub package_name: String,
    /// Package version
    pub version: String,
    /// Package description
    pub description: String,
    /// Python module name (e.g., "_rust")
    pub python_module_name: String,
    /// Minimum Python version
    pub min_python_version: String,
    /// Path to nomnom library (relative or absolute)
    pub nomnom_path: String,
    /// Additional dependencies
    pub dependencies: Vec<String>,
}

impl Default for BuildConfig {
    fn default() -> Self {
        Self {
            package_name: "generated_project".to_string(),
            version: "0.1.0".to_string(),
            description: "Auto-generated data transformation library".to_string(),
            python_module_name: "_rust".to_string(),
            min_python_version: "3.8".to_string(),
            nomnom_path: "../../../nomnom".to_string(),
            dependencies: Vec::new(),
        }
    }
}

/// Generate Cargo.toml for the build output
///
/// # Arguments
/// * `config` - Build configuration
///
/// # Returns
/// Generated Cargo.toml content
pub fn generate_cargo_toml(config: &BuildConfig) -> String {
    format!(r#"[package]
name = "{}_rust"
version = "{}"
edition = "2021"

[lib]
name = "{}"
crate-type = ["cdylib"]
# Disable Rust doctests - use Python tests instead
doctest = false

[dependencies]
pyo3 = {{ version = "0.20", features = ["extension-module", "abi3-py38"] }}
serde = {{ version = "1.0", features = ["derive"] }}
serde_json = "1.0"
serde_yaml = "0.9"
once_cell = "1.19"
thiserror = "1.0"

# Diesel ORM with connection pooling
diesel = {{ version = "2.1", features = ["mysql", "sqlite", "r2d2", "chrono"] }}
diesel_migrations = "2.1"
r2d2 = "0.8"
chrono = {{ version = "0.4", features = ["serde"] }}

# Nomnom entity framework (runtime with python-bridge feature)
nomnom = {{ path = "{}", features = ["python-bridge"] }}

{}

[build-dependencies]
serde = {{ version = "1.0", features = ["derive"] }}
serde_yaml = "0.9"
glob = "0.3"
nomnom = {{ path = "{}" }}

# Note: We don't include dev-dependencies or benchmarks for cdylib
# Use Python tests instead (pytest tests/)
"#,
        config.package_name,
        config.version,
        config.python_module_name,
        config.nomnom_path,
        if config.dependencies.is_empty() {
            String::new()
        } else {
            format!("# Additional dependencies\n{}\n", config.dependencies.join("\n"))
        },
        config.nomnom_path
    )
}

/// Generate pyproject.toml for Python packaging
///
/// # Arguments
/// * `config` - Build configuration
///
/// # Returns
/// Generated pyproject.toml content
pub fn generate_pyproject_toml(config: &BuildConfig) -> String {
    let python_package_name = config.package_name.replace("_", "-");

    format!(r#"[build-system]
requires = ["maturin>=1.0,<2.0"]
build-backend = "maturin"

[project]
name = "{}"
version = "{}"
description = "{}"
readme = "README.md"
requires-python = ">={}""
license = {{text = "MIT"}}
authors = [
    {{name = "Generated by nomnom"}}
]
keywords = ["data-transformation", "etl", "parsing", "nomnom"]
classifiers = [
    "Development Status :: 3 - Alpha",
    "Intended Audience :: Developers",
    "License :: OSI Approved :: MIT License",
    "Programming Language :: Python :: 3",
    "Programming Language :: Python :: 3.8",
    "Programming Language :: Python :: 3.9",
    "Programming Language :: Python :: 3.10",
    "Programming Language :: Python :: 3.11",
    "Programming Language :: Python :: 3.12",
    "Programming Language :: Rust",
    "Topic :: Software Development :: Libraries",
]

dependencies = [
    "PyYAML>=6.0.2",
    "pydantic>=2.0.0",
]

[project.optional-dependencies]
test = [
    "pytest>=8.0.0",
    "pytest-benchmark>=5.0.0",
]
dev = [
    "maturin>=1.0.0",
    "ruff>=0.1.0",
]

[tool.maturin]
python-source = "python"
module-name = "{}.{}"
features = ["pyo3/extension-module"]
include = ["config/**/*.yaml"]

[tool.pytest.ini_options]
minversion = "8.0"
testpaths = ["tests"]
python_files = ["test_*.py"]
addopts = [
    "--strict-markers",
    "-ra",
]

[tool.ruff]
line-length = 100
target-version = "py38"
"#,
        python_package_name,
        config.version,
        config.description,
        config.min_python_version,
        config.package_name,
        config.python_module_name
    )
}

/// Generate lib.rs that ties everything together
///
/// # Arguments
/// * `has_entities` - Whether entities.rs was generated
/// * `has_transforms` - Whether transforms.rs was generated
///
/// # Returns
/// Generated lib.rs content
pub fn generate_lib_rs(has_entities: bool, has_transforms: bool) -> String {
    let mut code = String::new();

    code.push_str("//! Auto-generated library module.\n");
    code.push_str("//!\n");
    code.push_str("//! This file is auto-generated by nomnom.\n");
    code.push_str("//! DO NOT EDIT MANUALLY - changes will be overwritten.\n\n");

    code.push_str("use pyo3::prelude::*;\n");
    code.push_str("use serde::{Serialize, Deserialize};\n\n");

    // Add transform registry module (required by generated entities)
    code.push_str("/// Transform registry for field extraction\n");
    code.push_str("pub mod transform_registry {\n");
    code.push_str("    /// Transform registry for field extraction\n");
    code.push_str("    /// \n");
    code.push_str("    /// This is a stub implementation. Real transforms should be implemented\n");
    code.push_str("    /// by extending this type or providing actual transform functions.\n");
    code.push_str("    #[derive(Debug, Clone)]\n");
    code.push_str("    pub struct TransformRegistry;\n\n");
    code.push_str("    impl TransformRegistry {\n");
    code.push_str("        /// Create a new empty registry\n");
    code.push_str("        pub fn new() -> Self {\n");
    code.push_str("            Self\n");
    code.push_str("        }\n\n");
    code.push_str("        /// Call a transform by name with arguments\n");
    code.push_str("        /// \n");
    code.push_str("        /// This is a stub that returns an error for all transforms.\n");
    code.push_str("        /// To implement transforms, add `call_transform` method to this type.\n");
    code.push_str("        pub fn call_transform(\n");
    code.push_str("            &self,\n");
    code.push_str("            name: &str,\n");
    code.push_str("            _args: &std::collections::HashMap<String, serde_json::Value>,\n");
    code.push_str("        ) -> Result<serde_json::Value, String> {\n");
    code.push_str("            Err(format!(\"Transform '{}' not implemented in stub registry\", name))\n");
    code.push_str("        }\n");
    code.push_str("    }\n");
    code.push_str("}\n\n");

    // Include generated modules
    if has_entities {
        code.push_str("pub mod entities;\n");
    }
    if has_transforms {
        code.push_str("pub mod transforms;\n");
    }

    code.push_str("\n/// Python module initialization\n");
    code.push_str("#[pymodule]\n");
    code.push_str("fn _rust(_py: Python, _m: &PyModule) -> PyResult<()> {\n");

    if has_entities {
        code.push_str("    // Register entity classes\n");
        code.push_str("    // TODO: Auto-register all entity classes\n");
    }

    if has_transforms {
        code.push_str("    // Register transform functions\n");
        code.push_str("    // TODO: Auto-register all transforms\n");
    }

    code.push_str("    Ok(())\n");
    code.push_str("}\n");

    code
}

/// Generate README.md for the generated project
///
/// # Arguments
/// * `config` - Build configuration
///
/// # Returns
/// Generated README.md content
pub fn generate_readme(config: &BuildConfig) -> String {
    format!(r#"# {}

{}

## Auto-Generated Project

This project was automatically generated by [nomnom](https://github.com/scie-nz/ingestion/tree/main/nomnom),
a YAML-based code generation framework for data transformation libraries.

## Building

### Development Build

```bash
maturin develop
```

### Release Build

```bash
maturin build --release
```

## Testing

```bash
pytest tests/
```

## Generated From

This project was generated from YAML entity and transform definitions using:

```bash
nomnom build --config config --output .build --release
```

## Structure

- `src/lib.rs` - Main library entry point
- `src/entities.rs` - Auto-generated entity definitions
- `src/transforms.rs` - Auto-generated transform functions
- `Cargo.toml` - Rust dependencies and build configuration
- `pyproject.toml` - Python packaging configuration

## License

MIT
"#,
        config.package_name,
        config.description
    )
}

/// Write all build configuration files to the output directory
///
/// # Arguments
/// * `output_dir` - Output directory path
/// * `config` - Build configuration
/// * `has_entities` - Whether entities.rs exists
/// * `has_transforms` - Whether transforms.rs exists
///
/// # Returns
/// Ok(()) on success, Err with error message on failure
pub fn write_build_configs<P: AsRef<Path>>(
    output_dir: P,
    config: &BuildConfig,
    has_entities: bool,
    has_transforms: bool,
) -> Result<(), String> {
    let output_dir = output_dir.as_ref();

    // Generate Cargo.toml
    let cargo_toml = generate_cargo_toml(config);
    fs_utils::write_file(output_dir.join("Cargo.toml"), cargo_toml)
        .map_err(|e| format!("Failed to write Cargo.toml: {}", e))?;

    // Generate pyproject.toml
    let pyproject_toml = generate_pyproject_toml(config);
    fs_utils::write_file(output_dir.join("pyproject.toml"), pyproject_toml)
        .map_err(|e| format!("Failed to write pyproject.toml: {}", e))?;

    // Generate lib.rs
    let lib_rs = generate_lib_rs(has_entities, has_transforms);
    std::fs::create_dir_all(output_dir.join("src"))
        .map_err(|e| format!("Failed to create src directory: {}", e))?;
    fs_utils::write_file(output_dir.join("src/lib.rs"), lib_rs)
        .map_err(|e| format!("Failed to write lib.rs: {}", e))?;

    // Generate README.md
    let readme = generate_readme(config);
    fs_utils::write_file(output_dir.join("README.md"), readme)
        .map_err(|e| format!("Failed to write README.md: {}", e))?;

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_cargo_toml() {
        let config = BuildConfig::default();
        let cargo_toml = generate_cargo_toml(&config);

        assert!(cargo_toml.contains("[package]"));
        assert!(cargo_toml.contains("name = \"generated_project_rust\""));
        assert!(cargo_toml.contains("pyo3"));
        assert!(cargo_toml.contains("nomnom"));
    }

    #[test]
    fn test_generate_pyproject_toml() {
        let config = BuildConfig::default();
        let pyproject = generate_pyproject_toml(&config);

        assert!(pyproject.contains("[build-system]"));
        assert!(pyproject.contains("maturin"));
        assert!(pyproject.contains("name = \"generated-project\""));
    }

    #[test]
    fn test_generate_lib_rs() {
        let lib_rs = generate_lib_rs(true, true);

        assert!(lib_rs.contains("pub mod entities"));
        assert!(lib_rs.contains("pub mod transforms"));
        assert!(lib_rs.contains("#[pymodule]"));
    }

    #[test]
    fn test_generate_readme() {
        let config = BuildConfig::default();
        let readme = generate_readme(&config);

        assert!(readme.contains("# generated_project"));
        assert!(readme.contains("nomnom"));
        assert!(readme.contains("maturin"));
    }
}
