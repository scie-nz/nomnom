//! Python code generation.
//!
//! Generates Python mapping files and utility code from entity definitions.

use crate::codegen::types::EntityDef;
use std::io::Write;

/// Generate Python bindings for all entities
///
/// This is a placeholder that will be implemented during Phase 2
/// by extracting code from data_processor.
pub fn generate_python_bindings(
    entities: &[EntityDef],
    output_path: &str,
) -> Result<(), String> {
    // Placeholder implementation
    let _ = entities;
    let _ = output_path;

    eprintln!("PLACEHOLDER: generate_python_bindings will be implemented in Phase 2");
    Ok(())
}

/// Generate PyO3 wrapper for a single entity
pub fn generate_entity_binding(entity: &EntityDef) -> String {
    // Placeholder implementation
    format!("// Placeholder Python binding for {}\n", entity.name)
}

/// Generate Python mapping file for Rust core classes.
///
/// Creates a _generated.py file with:
/// - RUST_CORE_CLASSES: Map of entity names to Rust core classes
/// - RUST_CORES_AVAILABLE: Boolean flag for Rust availability
///
/// # Arguments
/// * `permanent_entities` - List of permanent entity definitions
/// * `output_path` - Path where _generated.py should be written
/// * `rust_module_path` - Python module path for Rust imports (e.g., "data_processor._rust")
///
/// # Example
/// ```rust,ignore
/// generate_python_core_mapping(
///     &permanent_entities,
///     "src/data_processor/query/permanent/_generated.py",
///     "data_processor._rust"
/// )?;
/// ```
pub fn generate_python_core_mapping(
    permanent_entities: &[EntityDef],
    output_path: &str,
    rust_module_path: &str,
) -> Result<(), String> {
    let mut file = crate::codegen::fs_utils::create_file(output_path)
        .map_err(|e| format!("Failed to create {}: {}", output_path, e))?;

    // Header
    writeln!(file, "\"\"\"Auto-generated Rust core to entity name mapping.")
        .map_err(|e| e.to_string())?;
    writeln!(file, "")
        .map_err(|e| e.to_string())?;
    writeln!(file, "This file is generated by nomnom during Rust compilation.")
        .map_err(|e| e.to_string())?;
    writeln!(file, "DO NOT EDIT - regenerate with `cargo build` or `make dev`.")
        .map_err(|e| e.to_string())?;
    writeln!(file, "")
        .map_err(|e| e.to_string())?;
    writeln!(file, "Used to connect Python permanent entities to Rust cores.")
        .map_err(|e| e.to_string())?;
    writeln!(file, "\"\"\"")
        .map_err(|e| e.to_string())?;
    writeln!(file, "from typing import Dict, Type, Any")
        .map_err(|e| e.to_string())?;
    writeln!(file, "")
        .map_err(|e| e.to_string())?;

    // All permanent entities have Rust cores (they're all from config/permanent/)
    let entities_with_cores: Vec<&EntityDef> = permanent_entities.iter().collect();

    // Generate imports
    writeln!(file, "try:")
        .map_err(|e| e.to_string())?;
    write!(file, "    from {} import (", rust_module_path)
        .map_err(|e| e.to_string())?;

    if !entities_with_cores.is_empty() {
        writeln!(file, "")
            .map_err(|e| e.to_string())?;
        for (i, entity) in entities_with_cores.iter().enumerate() {
            let comma = if i < entities_with_cores.len() - 1 { "," } else { "" };
            writeln!(file, "        {}Core{}", entity.name, comma)
                .map_err(|e| e.to_string())?;
        }
        writeln!(file, "    )")
            .map_err(|e| e.to_string())?;
    } else {
        writeln!(file, ")")
            .map_err(|e| e.to_string())?;
    }

    writeln!(file, "    RUST_CORES_AVAILABLE = True")
        .map_err(|e| e.to_string())?;
    writeln!(file, "except ImportError:")
        .map_err(|e| e.to_string())?;
    writeln!(file, "    # Rust extension not built - will use Python extraction")
        .map_err(|e| e.to_string())?;
    writeln!(file, "    RUST_CORES_AVAILABLE = False")
        .map_err(|e| e.to_string())?;
    writeln!(file, "")
        .map_err(|e| e.to_string())?;

    // Generate RUST_CORE_CLASSES mapping
    writeln!(file, "# Map entity name to Rust core class")
        .map_err(|e| e.to_string())?;
    writeln!(file, "# Example: 'MPI' -> MPICore")
        .map_err(|e| e.to_string())?;
    writeln!(file, "if RUST_CORES_AVAILABLE:")
        .map_err(|e| e.to_string())?;
    writeln!(file, "    RUST_CORE_CLASSES: Dict[str, Type[Any]] = {{")
        .map_err(|e| e.to_string())?;

    for entity in &entities_with_cores {
        writeln!(file, "        '{}': {}Core,", entity.name, entity.name)
            .map_err(|e| e.to_string())?;
    }

    writeln!(file, "    }}")
        .map_err(|e| e.to_string())?;
    writeln!(file, "else:")
        .map_err(|e| e.to_string())?;
    writeln!(file, "    RUST_CORE_CLASSES: Dict[str, Type[Any]] = {{}}")
        .map_err(|e| e.to_string())?;

    Ok(())
}

#[cfg(test)]
mod tests {
    #[test]
    fn test_placeholder() {
        // Tests will be added during Phase 2 extraction
    }
}
