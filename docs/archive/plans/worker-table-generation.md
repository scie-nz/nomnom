# Plan: Fix Worker Table Auto-Creation

## Date
2025-11-12

## Problem Statement

The nomnom worker has table auto-creation logic in `src/codegen/worker/database_rs.rs`, but it contains critical bugs that prevent it from creating valid database tables. This causes the worker to crash when tables don't exist, and the dashboard backend to fail when polling for data.

## Investigation Summary

### Current State
- **Location**: `/Users/bogdanstate/nomnom/src/codegen/worker/database_rs.rs` (lines 61-151)
- **Function**: `ensure_tables()` - Called on worker startup to create missing tables
- **Status**: Contains table generation logic but with multiple critical bugs

### Evidence
1. Worker pod crashes in Kubernetes with CLI help output instead of running (wrong binary deployed)
2. Dashboard backend errors: `relation "orders" does not exist`
3. Generated worker code exists but has incorrect table schema generation

## Root Cause Analysis

### Issue 1: Missing Primary Key Column ⚠️ CRITICAL
**Location**: `database_rs.rs:84-115`

**Problem**:
- The `id` column defined in `persistence.primary_key` is NOT included in the generated CREATE TABLE
- Code only iterates over `field_overrides`, which doesn't include the primary key
- Results in tables without a PRIMARY KEY column

**Example**:
```yaml
# Order.yaml
persistence:
  primary_key:
    name: id
    type: Integer
    autogenerate: true
  field_overrides:
    - name: order_key  # id is NOT in this list
    - name: customer_key
```

**Current Generated SQL**:
```sql
CREATE TABLE IF NOT EXISTS orders (
    order_key VARCHAR(255) PRIMARY KEY,  -- WRONG! Should be 'id SERIAL PRIMARY KEY'
    customer_key VARCHAR(255) NOT NULL,
    ...
)
```

**Expected SQL**:
```sql
CREATE TABLE IF NOT EXISTS orders (
    id SERIAL PRIMARY KEY,               -- CORRECT!
    order_key TEXT NOT NULL,
    customer_key TEXT NOT NULL,
    ...
)
```

### Issue 2: Wrong Primary Key Detection ⚠️ CRITICAL
**Location**: `database_rs.rs:103-106`

**Problem**:
```rust
// CURRENT (WRONG):
if !field_lines.is_empty() {
    field_lines[0] = format!("{} PRIMARY KEY", field_lines[0]);
}
```

This assumes the first field in `field_overrides` is the primary key, which is incorrect.

**Should be**:
```rust
// Use persistence.primary_key.name instead
let pk_name = persistence.primary_key.as_ref()
    .map(|pk| pk.name.to_lowercase())
    .unwrap_or_else(|| "id".to_string());
```

### Issue 3: Missing SERIAL Type for Auto-Increment ⚠️ CRITICAL
**Location**: `database_rs.rs:89-97`

**Problem**:
- Uses `INTEGER` for primary keys instead of `SERIAL`
- Doesn't check `persistence.primary_key.autogenerate`
- Results in primary keys that don't auto-increment

**Current**:
```rust
"i32" | "i64" | "Integer" => "INTEGER",  // WRONG for autogenerated PKs
```

**Should be**:
```rust
if pk_config.autogenerate.unwrap_or(false) {
    "SERIAL"  // or "BIGSERIAL" for i64
}
```

### Issue 4: Incorrect SQL Type Mapping ⚠️ MEDIUM
**Location**: `database_rs.rs:89-97`

**Problems**:
1. Uses `VARCHAR(255)` instead of `TEXT` (PostgreSQL best practice)
2. Uses `DOUBLE PRECISION` instead of `NUMERIC` for decimals (precision loss)
3. Doesn't support `JSONB` for complex fields
4. Doesn't support `TIMESTAMP` for datetime fields

**Current Mapping**:
```rust
"String" => "VARCHAR(255)",           // WRONG: Should be TEXT
"f64" | "Float" => "DOUBLE PRECISION", // WRONG: Should be NUMERIC
"Decimal" => "NUMERIC",                // Correct
```

**Comparison with Manual Migration**:
```sql
-- Manual migration (config/examples/tpch/migrations/.../up.sql)
order_key TEXT NOT NULL,              -- Uses TEXT
total_price NUMERIC NOT NULL,         -- Uses NUMERIC
line_items JSONB,                     -- Uses JSONB

-- Generated by worker (WRONG)
order_key VARCHAR(255) NOT NULL,      -- Uses VARCHAR
total_price DOUBLE PRECISION NOT NULL,-- Uses DOUBLE PRECISION
line_items VARCHAR(255),              -- Can't store JSONB!
```

### Issue 5: Missing UNIQUE Constraints ⚠️ HIGH
**Location**: `database_rs.rs:79-119`

**Problem**:
- `unicity_fields` from entity config are completely ignored
- No UNIQUE constraints generated
- Allows duplicate business keys (e.g., duplicate `order_key`)

**Entity Config**:
```yaml
persistence:
  database:
    unicity_fields:
      - order_key  # Should create UNIQUE constraint
```

**Expected SQL**:
```sql
CREATE TABLE orders (
    id SERIAL PRIMARY KEY,
    order_key TEXT NOT NULL,
    ...,
    CONSTRAINT orders_order_key_unique UNIQUE (order_key)
);
```

**Current Generated**: No constraint at all

### Issue 6: Missing Indices ⚠️ MEDIUM
**Location**: `database_rs.rs:79-151`

**Problem**:
- No indices created for unicity fields or foreign keys
- Poor query performance for lookups

**Expected**:
```sql
CREATE INDEX idx_orders_order_key ON orders(order_key);
CREATE INDEX idx_orders_customer_key ON orders(customer_key);
```

**Current**: No indices generated

### Issue 7: Derived Entities Excluded from Table Generation ⚠️ CRITICAL
**Location**: `database_rs.rs:69`

**Problem**:
- The code filters out non-root entities: `if !entity.is_root() || !entity.is_persistent() || entity.is_abstract { continue; }`
- Derived entities like OrderLineItem have `source_type: derived` which makes them non-root
- These entities still have full persistence configuration and need their own tables
- Results in missing tables for child/derived entities

**Example**:
```yaml
# orderlineitem.yaml
entity:
  name: OrderLineItem
  source_type: derived  # This makes is_root() return false
  repeated_for:
    entity: Order
    field: line_items

  persistence:
    database:
      conformant_table: order_line_items  # Should create this table!
    primary_key:
      name: id
      autogenerate: true
    field_overrides:
      - name: order_key
      - name: line_number
      # ... more fields
```

**Current Behavior**: OrderLineItem table is never created because `!entity.is_root()` returns true

**Expected Behavior**: All entities with persistence configuration should have tables created, regardless of source_type

**Fix**: Change the filter to check for persistence instead of root status:
```rust
// BEFORE:
if !entity.is_root() || !entity.is_persistent() || entity.is_abstract {
    continue;
}

// AFTER:
// Skip entities without persistence or abstract entities
if !entity.is_persistent() || entity.is_abstract {
    continue;
}

// Skip reference entities (read from external sources)
if entity.source_type.to_lowercase() == "reference" {
    continue;
}
```

## Proposed Solution

### Fix 1: Add Primary Key Column Generation (HIGH PRIORITY)

**File**: `src/codegen/worker/database_rs.rs`
**Lines**: 82-115

**Change**:
```rust
// BEFORE: Only iterate over field_overrides
for field in &persistence.field_overrides {
    // Generate column
}

// AFTER: Add primary key FIRST, then field_overrides
let mut field_lines = Vec::new();

// 1. Add primary key column if autogenerate=true
if let Some(ref pk_config) = persistence.primary_key {
    if pk_config.autogenerate.unwrap_or(false) {
        let pk_type = match pk_config.field_type.as_deref().unwrap_or("Integer") {
            "i64" | "BigInt" => "BIGSERIAL",
            _ => "SERIAL"
        };
        field_lines.push(format!(
            "            {} {} PRIMARY KEY",
            pk_config.name.to_lowercase(),
            pk_type
        ));
    }
}

// 2. Add all field_overrides (existing logic)
for field in &persistence.field_overrides {
    let col_name = field.name.to_lowercase();
    let field_type_str = field.field_type.as_deref().unwrap_or("String");
    let sql_type = map_field_to_sql_type(field_type_str);
    let nullable = if field.nullable.unwrap_or(false) { "" } else { " NOT NULL" };
    field_lines.push(format!("            {} {}{}", col_name, sql_type, nullable));
}

// 3. Remove the old wrong primary key logic
// DELETE: if !field_lines.is_empty() { field_lines[0] = format!("{} PRIMARY KEY", ...); }
```

### Fix 2: Proper SQL Type Mapping (HIGH PRIORITY)

**File**: `src/codegen/worker/database_rs.rs`
**Lines**: 89-97

**Change**:
```rust
// BEFORE:
let sql_type = match field_type_str {
    "String" => "VARCHAR(255)",              // WRONG
    "i32" | "i64" | "Integer" => "INTEGER",  // WRONG for PKs
    "f64" | "Float" => "DOUBLE PRECISION",   // WRONG for decimals
    "bool" => "BOOLEAN",
    "NaiveDate" => "DATE",
    "Decimal" => "NUMERIC",
    _ => "VARCHAR(255)",
};

// AFTER:
fn map_field_to_sql_type(field_type: &str) -> &'static str {
    match field_type {
        "String" => "TEXT",                     // PostgreSQL best practice
        "i32" | "Integer" => "INTEGER",
        "i64" | "BigInt" => "BIGINT",
        "f64" | "Float" | "Decimal" => "NUMERIC", // Preserve precision
        "bool" | "Boolean" => "BOOLEAN",
        "NaiveDate" => "DATE",
        "NaiveDateTime" | "DateTime" => "TIMESTAMP",
        "Json" | "Object" | "List[Object]" => "JSONB",  // Support complex types
        _ => "TEXT",  // Safe default
    }
}
```

### Fix 3: Add UNIQUE Constraints (HIGH PRIORITY)

**File**: `src/codegen/worker/database_rs.rs`
**Lines**: 115-119 (after closing parenthesis of CREATE TABLE)

**Change**:
```rust
// BEFORE:
writeln!(output, "        )")?;
writeln!(output, "    \"#)")?;

// AFTER:
writeln!(output, "        )")?;

// Add UNIQUE constraints for unicity_fields
if let Some(ref db_config) = persistence.database {
    for unicity_field in &db_config.unicity_fields {
        writeln!(output, "        ,CONSTRAINT {}_{}_unique UNIQUE ({})",
            table_name,
            unicity_field.to_lowercase(),
            unicity_field.to_lowercase()
        )?;
    }
}

writeln!(output, "    \"#)")?;
```

### Fix 4: Add Index Creation (MEDIUM PRIORITY)

**File**: `src/codegen/worker/database_rs.rs`
**Lines**: 119-120 (after CREATE TABLE execution)

**Change**:
```rust
writeln!(output, "    .execute(conn)?;\n")?;

// NEW: Create indices for unicity fields and frequently queried columns
if let Some(ref db_config) = persistence.database {
    for unicity_field in &db_config.unicity_fields {
        writeln!(output, "    // Index for {}", unicity_field)?;
        writeln!(output, "    diesel::sql_query(r#\"")?;
        writeln!(output, "        CREATE INDEX IF NOT EXISTS idx_{}_{}",
            table_name,
            unicity_field.to_lowercase()
        )?;
        writeln!(output, "        ON {}({})",
            table_name,
            unicity_field.to_lowercase()
        )?;
        writeln!(output, "    \"#)")?;
        writeln!(output, "    .execute(conn)?;\n")?;
    }
}
```

### Fix 5: Include Derived Entities in Table Generation (CRITICAL PRIORITY)

**File**: `src/codegen/worker/database_rs.rs`
**Lines**: 68-75

**Change**:
```rust
// BEFORE:
for entity in entities {
    if !entity.is_root() || !entity.is_persistent() || entity.is_abstract {
        continue;
    }
    if entity.source_type.to_lowercase() == "reference" {
        continue;
    }
    // ... table generation code
}

// AFTER:
for entity in entities {
    // Skip entities without persistence or abstract entities
    if !entity.is_persistent() || entity.is_abstract {
        continue;
    }

    // Skip reference entities (read from external sources, not stored locally)
    if entity.source_type.to_lowercase() == "reference" {
        continue;
    }

    // Generate table for this entity (root or derived with persistence)
    let db_config = entity.get_database_config().unwrap();
    let table_name = &db_config.conformant_table;
    // ... rest of table generation code
}
```

**Rationale**:
- Root entities (e.g., Order) need tables ✓
- Derived entities with persistence (e.g., OrderLineItem) need tables ✓
- Reference entities don't need tables (read-only from external sources) ✓
- Abstract entities don't need tables (templates for other entities) ✓

## Implementation Steps

### Step 1: Apply Code Fixes
1. Modify `src/codegen/worker/database_rs.rs` with all fixes above
2. Test compilation: `cargo build`
3. Run tests if available: `cargo test`

### Step 2: Regenerate Worker
1. Build nomnom binary: `cargo build --bin nomnom` (with RUSTFLAGS for PostgreSQL)
2. Generate fresh worker code:
   ```bash
   ./target/debug/nomnom generate-worker \
     --entities config/examples/tpch/entities \
     --output /tmp/worker-test \
     --database postgresql
   ```
3. Verify generated `src/database.rs` contains:
   - `id SERIAL PRIMARY KEY` column
   - All `field_overrides` columns
   - UNIQUE constraints
   - CREATE INDEX statements

### Step 3: Build Worker Binary
1. Navigate to generated worker: `cd /tmp/worker-test`
2. Build worker binary: `cargo build --bin worker`
3. Verify binary exists: `ls -lh target/debug/worker`

### Step 4: Update Docker Build
1. Update `Dockerfile.worker-dev-complete` to build correct binary
2. Ensure it builds `worker` not `nomnom`
3. Build Docker image: `docker build -f Dockerfile.worker-dev-complete -t nomnom-worker:test .`

### Step 5: Deploy to Kubernetes
1. Update test script if needed
2. Deploy with: `./test-helm-kind.sh --dev`
3. Verify worker starts without crashes

### Step 6: Verification
1. Check worker logs for table creation messages
2. Verify tables exist:
   ```bash
   kubectl exec -n nomnom-dev nomnom-postgres-0 -- psql -U postgres -d nomnom -c "\d orders"
   ```
3. Verify table schema matches expectations:
   - `id SERIAL PRIMARY KEY`
   - All business fields
   - UNIQUE constraints
   - Indices
4. Test message ingestion through ingestion API
5. Verify dashboard backend can poll tables without errors

## Expected Results

### Before Fix
```sql
-- Generated by worker (WRONG)
CREATE TABLE IF NOT EXISTS orders (
    order_key VARCHAR(255) PRIMARY KEY,  -- Business key as PK!
    customer_key VARCHAR(255) NOT NULL,
    order_status VARCHAR(255) NOT NULL,
    total_price DOUBLE PRECISION NOT NULL,
    order_date VARCHAR(255) NOT NULL,
    order_priority VARCHAR(255),
    clerk VARCHAR(255),
    ship_priority INTEGER,
    comment VARCHAR(255)
);
-- No UNIQUE constraints
-- No indices
```

### After Fix
```sql
-- Generated by worker (CORRECT)
CREATE TABLE IF NOT EXISTS orders (
    id SERIAL PRIMARY KEY,                -- Auto-increment PK
    order_key TEXT NOT NULL,              -- Business key as regular field
    customer_key TEXT NOT NULL,
    order_status TEXT NOT NULL,
    total_price NUMERIC NOT NULL,         -- Precise decimal
    order_date TEXT NOT NULL,
    order_priority TEXT,
    clerk TEXT,
    ship_priority INTEGER,
    comment TEXT
    ,CONSTRAINT orders_order_key_unique UNIQUE (order_key)  -- Unicity
);

CREATE INDEX IF NOT EXISTS idx_orders_order_key ON orders(order_key);
CREATE INDEX IF NOT EXISTS idx_orders_customer_key ON orders(customer_key);
```

## Risks & Mitigation

### Risk 1: Breaking Existing Deployments
**Mitigation**: This is new functionality, no existing deployments rely on auto-generated tables

### Risk 2: Type Mapping Incompatibilities
**Mitigation**:
- Match types from manual migration file
- Test with all entity types in TPC-H example
- Add type mapping tests

### Risk 3: Performance Impact from Indices
**Mitigation**:
- Only create indices for unicity_fields (already identified as important)
- Indices improve query performance for dashboard polling

## Testing Checklist

- [ ] Code compiles without warnings
- [ ] Worker generates correct SQL for Order entity
- [ ] Worker generates correct SQL for OrderLineItem entity
- [ ] Generated tables match manual migration schema
- [ ] Worker binary starts successfully
- [ ] Tables are created on worker startup
- [ ] Dashboard backend can query tables
- [ ] Message ingestion works end-to-end
- [ ] UNIQUE constraints prevent duplicates
- [ ] Indices are created correctly

## Rollback Plan

If issues occur:
1. Revert changes to `src/codegen/worker/database_rs.rs`
2. Rebuild nomnom binary
3. Regenerate worker with old code
4. Redeploy worker

## Follow-Up Tasks

### Short Term
- Apply same fixes to dashboard table generation (if applicable)
- Update documentation about table auto-creation
- Add warning that manual migrations are preferred for production

### Long Term
- Extract table generation into shared module (DRY principle)
- Consider generating proper Diesel migrations instead of CREATE TABLE IF NOT EXISTS
- Add configuration option to disable auto-creation in production
- Create migration tool to convert auto-created tables to Diesel migrations

## References

- Entity Config: `/Users/bogdanstate/nomnom/config/examples/tpch/entities/Order.yaml`
- Manual Migration: `/Users/bogdanstate/nomnom/config/examples/tpch/migrations/2025-01-01-000000_create_tpch_tables/up.sql`
- Worker Codegen: `/Users/bogdanstate/nomnom/src/codegen/worker/database_rs.rs`
- Dashboard Fix (similar pattern): `/Users/bogdanstate/nomnom/src/codegen/dashboard/axum_backend.rs` (lines 243-256, 319-332)
